#!/usr/bin/env python

import re, os, sys, subprocess
import argparse
from argparse import RawTextHelpFormatter

###################################################
### 0. script description and parsing arguments ###
###################################################

synopsis1 = "\
  a wrapper script to run 'CL_finder.py' for all possible pairs among species\n\
  given as an input, and create reports and other files for downstream scripts\n\
  such as 'update_BestHitPairs.py', 'pairwiseKs_by_codeml.py', \n\
  and 'create_OrthNet.py'"
synopsis2 = "detailed description:\n\
 0. Pre-requisite: 'CL_finder.py' should be available in $PATH.\n\
 1. Input files and parameters:\n\
  - './<Project>.list' includes all species IDs (spcsIDs), one per each line.\n\
  - '-t Path2TDfiles': path to output files of 'TD_finder.py' ('TDfiles'),\n\
  - '-T TDfile_nameFmt': expects TDfiles named as spcsID + TDfile_nameFmt\n\
  - '-b Path2BHPs': path to 'BestHitPairs(BHPs)' files for all possible\n\
     species pairs with file names 'BestHits__spcsID1_vs_spcsID2.list'.\n\
  - '-u'|'--updatedBHPs' assumes 'BestHitPairs' files generated by\n\
     'update_BestHitPairs.py' or 'updated_OrthNet_after_mcl.py' (itself).\n\
  - for optional <window_size>, <num_CL_trshld>, and <gap_CL_trshld> parameters\n\
     see 'CL_finder.py -h'; defaults = 20, 4, 20, respectively.\n\
 2-1. Output files (default):\n\
  - each species in '<Project>.list' are compared to all others, by iterative\n\
     'CL_finder.py' runs, with results written as, for example,\n\
     'spcsID1.CL_compared2spcsID2spcsID3...spcsIDn.20.4.20.txt'.\n\
 2-2. Output files (optional):\n\
  - '-o Path2Output': path to temp. and output files (default='.\Output').\n\
  - '-r'|'--report': creates report files per each viewpoint counting:\n\
     (1) occurrences of each CL types for all comparisons,\n\
     (2) occurrences of all combinatorial patterns of CL types, and\n\
     (3) occurrences of all combinatorial patterns of TD-sharing among species.\n\
  - '-n'|'--forOrthNet': creates files required for creating 'OrthNet's.\n\
  - '-p'|'--forPairwiseKs': creates input files for 'pairwiseKs_by_codeml.py':\n\
     (1) for all TD genes with two members in each species and\n\
     (2) for all reciprocally 'bestHit' pairs, between all species pairs.\n\n\
 by ohdongha@gmail.com ver0.6.8 20180508\n"
 
#version_history
#20180508 ver 0.6.8 # BHP file format changed slightly from 'BestHits__%s__vs__%s.list' to 'BestHits__%s_vs_%s.list' ... for some reason 
#20180417 ver 0.6.7 # bug fix (the default '-T' option was omitted in the 0.6.6)
#20171225 ver 0.6.6 # accept TD_finder.py output file formats as a string ('-T' option); if <Project> argument ends with '.list', just ignore it
#20170810 ver 0.6.5 # bug fix (adding a bypass for ValueError during printing output for -p option)
#20170317 ver 0.6.4 # bug fix (*.rep1 counting error fixed)
#20170316 ver 0.6.3 # 'translocated (tlc)' is now called 'transposed (tr)'
#20161021 ver 0.6.2 # bug fix
#20161003 ver 0.6.1 # with '-n', print the list of main output files (i.e. '*.CL_compared2*.txt') to '<Project>_CLfm_output.list'
#20160820 ver 0.6 # works with 'update_OrthNet_after_mcl.py'
#20160627 ver 0.5 # accepts 'BestHitPairs' updated by 'update_BestHitPairs.py'
#20160614 ver 0.4 # accepts parameters as options
#20160505 ver 0.3.3 # creates input files for 'create_OrthNet.py'
#20160331 ver 0.3.2 # creates reports with two types of TD matrix
#20160330 ver 0.3.1 # adds simplified CL matrix to the end of the main file
#20160320 ver 0.3 # creates input files for 'pairwiseKs_by_codeml.py'
#20160311 ver 0.2 # creates stat reports
#20160304 ver 0.1 # can accept the 3 parameters for 'CL_finder.py' as arguments
#20160304 ver 0.0

parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

## positional arguments
parser.add_argument('Project', type=str, help="'./<Project>.list' includes spcsIDs being compared")

## options to receive PATH to input and output files
parser.add_argument('-t', dest="Path2TDfiles", type=str, default=".", help="PATH to 'TDfiles'; default='.'")
parser.add_argument('-T', dest="TDfile_nameFmt", type=str, default=".gtfParsed.pc.TD.txt", help="default='.gtfParsed.pc.TD.txt'; see below")
parser.add_argument('-b', dest="Path2BHPs", type=str, default=".", help="PATH to 'BestHitPairs' files; default='.'")
parser.add_argument('-o', dest="Path2Output", type=str, default=".", help="PATH for output files; default='.'") 

## option to accept 'BestHitPairs' files updated by 'update_BestHitPairs.py':
parser.add_argument('-u', '--updatedBHPs', action="store_true", default=False, help="use updated <BestHitPairs> files; see below")
## options for creating reports and additional output files (see the synopsis):
parser.add_argument('-r', '--report', action="store_true", default=False, help="create additional reports; see below")
parser.add_argument('-n', '--forOrthNet', action="store_true", default=False, help="create an input file for 'create_OrthNet.py'; see below")
parser.add_argument('-p', '--forPairwiseKs', action="store_true", default=False, help="create input files for 'pairwiseKs_by_codeml.py'; see below")

## options to set parameters to determine co-linearity (see the synopsis):
parser.add_argument('-W', dest="window_size", type=int, default=20, help="default=20; see below") 
# 'window_size' should be smaller than 'locusID_gap_between_chromosome' defined in TD_finder.py (200 by default)
parser.add_argument('-N', dest="num_CL_trshld", type=int, default=4, help="default=4; see below")
parser.add_argument('-G', dest="gap_CL_trshld", type=int, default=20, help="default=20; see below")

args = parser.parse_args()

# parameters for 'CL_finder.py'
window_size = args.window_size
num_CL_trshld = args.num_CL_trshld
gap_CL_trshld = args.gap_CL_trshld

# defining PATHs and create Output directory, if not already exisiting
path_TDfiles = args.Path2TDfiles
if path_TDfiles[-1] != "/": path_TDfiles = path_TDfiles + "/"
path_BestHitPairs = args.Path2BHPs
if path_BestHitPairs[-1] != "/": path_BestHitPairs = path_BestHitPairs + "/"
path_output = args.Path2Output
if path_output[-1] != "/": path_output = path_output + "/"

try: 
	os.makedirs(path_output)
except OSError:
	if not os.path.isdir(path_output): raise

## defining expected format of input and output file names.  modify as needed: 
input_TDfiles_filename_format = path_TDfiles + "%s" + args.TDfile_nameFmt
input_BestHitPairs_filename_format = path_BestHitPairs + "BestHits__%s_vs_%s.list" # v0.6.8
temp_filename_1_format = path_output + "temp_filename_1." + str(window_size) + "." + str(num_CL_trshld) + "." + str(gap_CL_trshld) + "_%s" 
temp_filename_2_format = path_output + "temp_filename_2." + str(window_size) + "." + str(num_CL_trshld) + "." + str(gap_CL_trshld) + "_%s" 
output_filename_format = path_output + "%s.CL_compared2%s." + str(window_size) + "." + str(num_CL_trshld) + "." + str(gap_CL_trshld) + ".txt"
output_filename_for_pairwiseKs_1_format = path_output + "%s_TDm2only_pairwiseKs_IN.list"
output_filename_for_pairwiseKs_2_format = path_output + "%s%s_rcBestHitAll_pairwiseKs_IN.list"
output_filename_for_pairwiseKs_3_format = path_output + "%s%s_rcBestHitCL_pairwiseKs_IN.list"


################################
### 1. reading the list file ###
################################
projectID = args.Project
try:
	fin_SpcsList = open(projectID + '.list', 'r')
except IOError:
	fin_SpcsList = open(projectID, 'r')
	projectID = projectID[:-5]
spcsID_list = []

print "\nreading the list file:" + fin_SpcsList.name
for line in fin_SpcsList:
	spcsID_list.append(line.strip())
	print line.strip()
fin_SpcsList.close()
print "Total %d species IDs detected." % (len(spcsID_list))

## v0.6.8: this is to accept both old and new BHP file name formats ... why I am bothering with this ...
if not os.path.isfile(input_BestHitPairs_filename_format % (spcsID_list[0], spcsID_list[1])):
	if os.path.isfile(path_BestHitPairs + "BestHits__%s__vs__%s.list" % (spcsID_list[0], spcsID_list[1])):
		input_BestHitPairs_filename_format = path_BestHitPairs + "BestHits__%s__vs__%s.list" 

		
################################
### 2. starting the pipeline ###
################################

spcs_viewpoint = ""
spcs_2bCompared = ""
spcs_added = ""
num_spcs_added = 0
first_comparison = True
filename_TD = ""
filename_TD2bAdded = ""
filename_blast = ""
filename_output = ""

geneID_dict = dict()
bestHit_CLtype_dict = dict() # key = query_spcsID, value = dict with key = locusID, value = dict with key = target_spcsID, value = [ BH_locusID, clType ]

# with '-n' option, open fout_4OrthNet and '<Project>_CLfm_output.list'
if args.forOrthNet == True:
	fout_4OrthNet = open(path_output + projectID + ".4OrthNet.input", "w" )
	print "\ncreating the input file for 'create_OrthNet.py': " + fout_4OrthNet.name
	fout_output_list = open(path_output + projectID + "_CLfm_output.list", "w" )
	print "\nCLfm main output file names (required for 'update_OrthNet_after_mcl.py')are printed to: " + fout_output_list.name

for i in range( len(spcsID_list) ):
	spcs_viewpoint = spcsID_list[i]
	spcs_2bCompared = ""
	spcs_added = ""
	num_spcs_added = 0
	first_comparison = True

	#####################################################################################################
	## 2.1 run 'CL_finder.py' for each viewpoint, for all possible pairs, to create the main output file:
	#####################################################################################################
	print "\n\nprocessing %s as the viewpoint, comparing with the other species:" % spcs_viewpoint
	for j in range( len(spcsID_list) ):
		if spcsID_list[j] != spcs_viewpoint:
			spcs_2bCompared = spcsID_list[j]
			spcs_added = spcs_added + spcs_2bCompared
			num_spcs_added = num_spcs_added + 1
			if first_comparison:
				filename_TD = input_TDfiles_filename_format % spcs_viewpoint
				filename_TD2bAdded = input_TDfiles_filename_format % spcs_2bCompared
				filename_blast = input_BestHitPairs_filename_format % (spcs_viewpoint, spcs_2bCompared)
				filename_output = temp_filename_2_format % spcs_viewpoint
				first_comparison = False
			else:
				subprocess.call("mv " + temp_filename_2_format % spcs_viewpoint + " " + temp_filename_1_format % spcs_viewpoint, shell=True)
				filename_TD = temp_filename_1_format % spcs_viewpoint
				filename_TD2bAdded = input_TDfiles_filename_format % spcs_2bCompared
				filename_blast = input_BestHitPairs_filename_format % (spcs_viewpoint, spcs_2bCompared)
				filename_output = temp_filename_2_format % spcs_viewpoint
			if args.updatedBHPs == True:
				subprocess.call("CL_finder.py -u " + filename_TD + " " + filename_TD2bAdded + " " + filename_blast + " " + filename_output + " -W " \
								+ str(window_size) + " -N " + str(num_CL_trshld) + " -G " + str(gap_CL_trshld), shell=True)
			else:
				subprocess.call("CL_finder.py " + filename_TD + " " + filename_TD2bAdded + " " + filename_blast + " " + filename_output + " -W " \
								+ str(window_size) + " -N " + str(num_CL_trshld) + " -G " + str(gap_CL_trshld), shell=True)
	if len(spcsID_list) > 2: 
		subprocess.call("rm " + temp_filename_1_format % spcs_viewpoint, shell=True)
	subprocess.call("mv " + temp_filename_2_format % spcs_viewpoint + " " + output_filename_format % (spcs_viewpoint, spcs_added), shell=True)
	
	##############################################################################################
	## 2.2 post-processing to add 'CL_matrix' to output files, and also for optional output files:
	## ... with "-n" option, create an input file for 'create_OrthNet.py' as well
	##############################################################################################
	fin_mainOutput2bAnalyzed = open( output_filename_format % (spcs_viewpoint, spcs_added), "rU" )
	
	# with '-n' option, write the main output file name into a list.
	if args.forOrthNet == True:
		fout_output_list.write(fin_mainOutput2bAnalyzed.name + '\n')
	
	header = True
	spcs_2bCompared = ""
	columns_2bCounted = []
	headers_2bCounted = []	
	headers_2bCounted_simplifed = []	
	spcs_2bCompared_all = ""
	spcs_2bCompared_all_simplified = ""
	locusID = 0

	geneID_viewpoint = ""
	geneID_2bCompared = ""
	
	bestHit_CLtype_dict[spcs_viewpoint] = dict() # key = locusID, value = dict with key = target_spcsID, value = [ BH_locusID, clType ]
	geneID_dict[spcs_viewpoint] = dict()
	CL_matrix_dict = dict()
	
	CL_types_occurence_dict = dict()
	CL_matrix_occurence_dict = dict()
		
	TD_type_dict = dict()
	TD_type_simplified_dict = dict()
	TD_BestHitTDs_dict = dict()
	TD_members_dict = dict()
	TD_matrix_occurence_dict = dict()
	TD_matrix_numberOfGenes_dict = dict()
	TD_matrix_simplified_occurence_dict = dict()
	TD_matrix_simplified_numberOfGenes_dict = dict()
	
	CL_type = ""
	TD_type = ""
	CL_matrix = []
	
	for line in fin_mainOutput2bAnalyzed:
		tok = line.split('\t')
		CL_matrix = []
		
		# parse the header, to find columns containing CL information and speciesIDs
		if header:
			k = 14 # 1st
			while k < len(tok) :
				columns_2bCounted.append(k)
				headers_2bCounted.append(tok[k])
				headers_2bCounted_simplifed.append( re.sub('_CL.*', '', tok[k]) )
				k = k + 5 # next column to be analyzed
			header = False
			if len(columns_2bCounted) != num_spcs_added:
				print "Error while creating reports!!"
			spcs_2bCompared_all = '\t'.join(headers_2bCounted).replace(spcs_viewpoint + '-', '')
			spcs_2bCompared_all_simplified = '\t'.join(headers_2bCounted_simplifed).replace(spcs_viewpoint + '-', '')

		# start counting CL type / matrix for non-headers 		
		else:
			# for report #1 and #2, and 'pairwiseKs_by_codeml.py' input file #1
			locusID = int(tok[12])
			bestHit_CLtype_dict[spcs_viewpoint][ locusID ] = dict() # key = target_spcsID, value = [ BH_locusID, clType ]
			geneID_viewpoint = tok[0].strip()
			geneID_dict[spcs_viewpoint][ locusID ] = geneID_viewpoint
			for k in range( len(columns_2bCounted) ):
				CL_type = tok[ columns_2bCounted[k] ]
				
				# simplifying CL_type:
				if 'u0' in CL_type or 'd0' in CL_type:
					CL_type = 'cl_end'
				elif 'cl_' in CL_type:
					CL_type = 'cl'

				# counting for the report #1
				if CL_type not in CL_types_occurence_dict:
					CL_types_occurence_dict[ CL_type ] = [0] * len(columns_2bCounted)
					CL_types_occurence_dict[ CL_type ][k] = CL_types_occurence_dict[ CL_type ][k] + 1
				else:
					CL_types_occurence_dict[ CL_type ][k] = CL_types_occurence_dict[ CL_type ][k] + 1

				# , for the report #2	
				CL_matrix.append(CL_type)
				
				# , and for the 'pairwiseKs_by_codeml.py' input file #2.
				# with '-n' option, adding to the 'create_OrthNet.py' input file
				spcs_2bCompared = re.sub( '_CL.*', '', headers_2bCounted[k].replace(spcs_viewpoint + '-', '') )
				bestHit_CLtype_dict[spcs_viewpoint][ locusID ][ spcs_2bCompared ] = [ tok[ columns_2bCounted[k] + 1 ], CL_type ]
				geneID_2bCompared = tok[ columns_2bCounted[k] + 1 ].strip()
				if geneID_2bCompared != 'na' and args.forOrthNet == True:
					fout_4OrthNet.write(spcs_viewpoint + '|' + tok[0].strip() + '\t' + spcs_2bCompared + '|' + geneID_2bCompared + '\t' + CL_type + '\n')
				
			# counting occurence of CL_matrix for report #2	
			CL_matrix_occurence_dict['\t'.join(CL_matrix)] = CL_matrix_occurence_dict.get('\t'.join(CL_matrix), 0)  + 1

			# assign CL_matrix for each locus for the viewpoint species
			CL_matrix_dict[ locusID ] = '.'.join(CL_matrix)
			
			# for the report #3 and 'pairwiseKs_by_codeml.py' input file #2
			if 'TD' in tok[13] :			
				# initialize TD dictionaries for a new entry:
				if tok[13] not in TD_type_dict:
					TD_type_dict[ tok[13] ] = [""] * len(columns_2bCounted)
					TD_BestHitTDs_dict[ tok[13] ] = [""] * len(columns_2bCounted)
					TD_members_dict[ tok[13] ] = [ tok[0] ]
				else:
					TD_members_dict[ tok[13] ].append( tok[0] ) 
				# decision tree to identify and assign TD_type:
				for k in range( len(columns_2bCounted) ):
					TD_type = TD_type_dict[ tok[13] ][k]
					if 'TD' in tok[ columns_2bCounted[k] + 4 ]:
						TD_BestHitTDs_dict[ tok[13] ][k] = tok[ columns_2bCounted[k] + 4 ].strip()
						if 'cl_' in tok[ columns_2bCounted[k] ] :
							TD_type_dict[ tok[13] ][k] = "TD_cl"
						elif 'tr' in tok[ columns_2bCounted[k] ] and TD_type != "TD_cl" :
							TD_type_dict[ tok[13] ][k] = "TD_tr"
						elif 'nd' in tok[ columns_2bCounted[k] ] and TD_type not in  ["TD_cl", "TD_tr"]:
							TD_type_dict[ tok[13] ][k] = "TD_nd"
						elif 'ls' in tok[ columns_2bCounted[k] ] and TD_type not in  ["TD_cl", "TD_tr", "TD_nd"]:
							TD_type_dict[ tok[13] ][k] = "TD_ls"
					elif 'TD' not in TD_type : 
						if 'cl_' in tok[ columns_2bCounted[k] ] :
							TD_type_dict[ tok[13] ][k] = "cl"
						elif 'tr' in tok[ columns_2bCounted[k] ] and TD_type != "cl" :
							TD_type_dict[ tok[13] ][k] = "tr"
						elif 'nd' in tok[ columns_2bCounted[k] ] and TD_type not in  ["cl", "tr"]:
							TD_type_dict[ tok[13] ][k] = "nd"
						elif 'ls' in tok[ columns_2bCounted[k] ] and TD_type not in  ["cl", "tr", "nd"]:
							TD_type_dict[ tok[13] ][k] = "ls"
					else:
						pass # if the besthit of one member is 'TD', the entire TD event is considered shared
	fin_mainOutput2bAnalyzed.close()			
	
	##################################################################################################
	# 2.3 add CL_matrix information for each locus, to the main output file for the viewpoint species: 
	##################################################################################################
	print "adding CL_matrix information to each locus, for viewpoint %s" % spcs_viewpoint	
	fin_mainOutput2bProcessed = open( output_filename_format % (spcs_viewpoint, spcs_added), "rU" )
	fout_mainOutput2bProcessed = open( output_filename_format % (spcs_viewpoint, spcs_added) + "_temp", "w" )

	header = True
	locusID = 0

	for line in fin_mainOutput2bProcessed:
		tok = line.split('\t')
		# process the header
		if header:
			fout_mainOutput2bProcessed.write( line.strip() + '\tCLmatrix_' + spcs_added + '\n') 
			header = False
		# start counting CL type / matrix for non-headers 		
		else:
			locusID = int(tok[12])
			fout_mainOutput2bProcessed.write( line.strip() + '\t' + CL_matrix_dict[locusID] + '\n')
			
	fin_mainOutput2bProcessed.close()
	fout_mainOutput2bProcessed.close()
	subprocess.call("mv " + output_filename_format % (spcs_viewpoint, spcs_added) + "_temp " + output_filename_format % (spcs_viewpoint, spcs_added), shell=True)	

	###################################################################################################################
	## 2.4 with '-r' and '-p' options, create reports and input files for 'pairwiseKs_by_codeml.py' for each viewpoint:
	###################################################################################################################
	# with '-r' option, writing 4 report files
	if args.report == True:
		print "\ncreating reports for viewpoint %s" % spcs_viewpoint
		fout_report1 = open( (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep1.txt" , "w")
		fout_report2 = open( (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep2.txt" , "w")
		fout_report3 = open( (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep3.txt" , "w")	
		fout_report4 = open( (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep4.txt" , "w")	

		# writing the report #1
		print "writing " + (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep1.txt"
		fout_report1.write(spcs_viewpoint + '-\t' + spcs_2bCompared_all + '\n')
		for key in sorted(CL_types_occurence_dict):
			fout_report1.write(key + '\t' + '\t'.join(str(x) for x in CL_types_occurence_dict[key]) + '\n')
			
		# writing the report #2		
		print "writing " + (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep2.txt"
		fout_report2.write(spcs_viewpoint + '-\t' + spcs_2bCompared_all + '\n')
		for key in sorted(CL_matrix_occurence_dict, key=CL_matrix_occurence_dict.get, reverse = True):
			fout_report2.write(str(CL_matrix_occurence_dict[key]) + '\t' + key + '\n')	
			
		# writing the report #3 and #4, for TD events
		print "writing " + (output_filename_format % (spcs_viewpoint, spcs_added))[:-4] + ".rep3.txt and .. .rep4.txt"
		fout_report3.write(spcs_viewpoint + '_TDid\tsimplified\tTDmatrix_' + spcs_added + '\t' + spcs_2bCompared_all_simplified + '\n')	
		for key in TD_type_dict:
			TD_type_simplified_dict[ key ] = [""] * len(columns_2bCounted)
			for k in range( len(columns_2bCounted) ):
				if 'TD' in TD_type_dict[ key ][ k ]:
					TD_type_simplified_dict[ key ][ k ] = "D"
				else:
					TD_type_simplified_dict[ key ][ k ] = "."
		for key in sorted(TD_type_dict):
			TD_matrix_occurence_dict['\t'.join( TD_type_dict[key] )] = TD_matrix_occurence_dict.get('\t'.join( TD_type_dict[key] ), 0) + 1
			TD_matrix_numberOfGenes_dict['\t'.join( TD_type_dict[key] )] = TD_matrix_numberOfGenes_dict.get('\t'.join( TD_type_dict[key] ), 0) + len( TD_members_dict[key] )
			TD_matrix_simplified_occurence_dict['\t'.join( TD_type_simplified_dict[key] )] = TD_matrix_simplified_occurence_dict.get('\t'.join( TD_type_simplified_dict[key] ), 0) + 1
			TD_matrix_simplified_numberOfGenes_dict['\t'.join( TD_type_simplified_dict[key] )] = TD_matrix_simplified_numberOfGenes_dict.get('\t'.join( TD_type_simplified_dict[key] ), 0) + len( TD_members_dict[key] )		
			fout_report3.write(key + '\t' + ''.join( TD_type_simplified_dict[key] ) + '\t' + '.'.join( TD_type_dict[key] )+ '\t' + '\t'.join( TD_BestHitTDs_dict[key] ) + '\n')
		fout_report4.write(spcs_viewpoint + '_#TDev\t#genes\t' + spcs_2bCompared_all_simplified + '\tsimplified\n')
		for key in sorted(TD_matrix_simplified_occurence_dict, key=TD_matrix_simplified_occurence_dict.get, reverse = True):
			fout_report4.write(str(TD_matrix_simplified_occurence_dict[key]) + '\t' + str(TD_matrix_simplified_numberOfGenes_dict[key]) + '\t' + key + '\t' + key.replace('\t', '') + '\n')
		fout_report4.write('\n')	
		fout_report4.write(spcs_viewpoint + '_#TDev\t#genes\t' + spcs_2bCompared_all_simplified + '\n')
		for key in sorted(TD_matrix_occurence_dict, key=TD_matrix_occurence_dict.get, reverse = True):
			fout_report4.write(str(TD_matrix_occurence_dict[key]) + '\t' + str(TD_matrix_numberOfGenes_dict[key]) + '\t' + key + '\n')
			
		fout_report1.close()
		fout_report2.close()
		fout_report3.close()
		fout_report4.close()
		
	# with '-p' option, writing the 'pairwiseKs_by_codeml.py' input file for all TD with two members
	if args.forPairwiseKs == True:
		print "\ncreating reports and input files for 'pairwiseKs_by_codeml.py', for viewpoint %s" % spcs_viewpoint
		fout_4pairwiseKs_TD = open( output_filename_for_pairwiseKs_1_format % spcs_viewpoint, "w")	
		
		print "writing " + output_filename_for_pairwiseKs_1_format % spcs_viewpoint
		for key in sorted(TD_members_dict):
			if len(TD_members_dict[key]) == 2:
				fout_4pairwiseKs_TD.write( key + '\t' + spcs_viewpoint + '\t' + TD_members_dict[key][0] + '\n')
				fout_4pairwiseKs_TD.write( key + '\t' + spcs_viewpoint + '\t' + TD_members_dict[key][1] + '\n')
	
		fout_4pairwiseKs_TD.close()

# # with '-n' option, close fout_4OrthNet and fout_output_list
if args.forOrthNet == True:
	fout_4OrthNet.close()
	fout_output_list.close()

		
#########################################################################################################		
# 3. with '-p' option, writing the 'pairwiseKs_by_codeml.py' input file for all reciprocal bestHit pairs:
#... this step needs to run after all viewpoints were fully processed. 
#########################################################################################################
if args.forPairwiseKs == True:
	print "\nwriting all reciprocal bestHit CL gene pairs, between all possible pairs of species, for 'pairwiseKs_by_codeml.py'." 
	
	spcs_pairs_compared = set()
	number_pairs_all = 0 
	number_pairs_CL = 0
	bestHit = []
	bestHit_locusID = 0
	bestHitOfBestHit = []
	
	for i in range( len(spcsID_list) ):
		spcs_viewpoint = spcsID_list[i]
		for j in range( len(spcsID_list) ):
			spcs_2bCompared = spcsID_list[j]
			if ( spcs_2bCompared != spcs_viewpoint ) and \
					(spcs_viewpoint + '-' + spcs_2bCompared not in spcs_pairs_compared) and \
					(spcs_2bCompared + '-' + spcs_viewpoint not in spcs_pairs_compared) :
	
				# preparing to add a new pairwise comparison
				fout_reciprocal_bestHitAll = open( output_filename_for_pairwiseKs_2_format % (spcs_viewpoint, spcs_2bCompared), "w" )
				fout_reciprocal_bestHitCL = open( output_filename_for_pairwiseKs_3_format % (spcs_viewpoint, spcs_2bCompared), "w")
				print "processing and writing the %s-%s pair :" % ( spcs_viewpoint, spcs_2bCompared )
				spcs_pairs_compared.add(spcs_viewpoint + '-' + spcs_2bCompared)
				number_pairs_all = 0 
				number_pairs_CL = 0
				
				for locusID in sorted(bestHit_CLtype_dict[spcs_viewpoint]):
					try:
						bestHit = bestHit_CLtype_dict[spcs_viewpoint][locusID][spcs_2bCompared]
						#print "bestHit: %s" % bestHit # for debugging
						if bestHit[0] != 'na':
							bestHit_locusID = geneID_dict[spcs_2bCompared].keys()[ geneID_dict[spcs_2bCompared].values().index( bestHit[0] ) ]				
							bestHitOfBestHit = bestHit_CLtype_dict[spcs_2bCompared][ bestHit_locusID ][spcs_viewpoint]				
							if geneID_dict[spcs_viewpoint][locusID] == bestHitOfBestHit[0]:
								number_pairs_all = number_pairs_all + 1
		#						if ( number_pairs_all % 1000 == 0):
		#							sys.stdout.write("\r   found %d and %d reciprocal bestHit and bestHit-CL pairs, respectively. " % ( number_pairs_all, number_pairs_CL))
		#							sys.stdout.flush()
								fout_reciprocal_bestHitAll.write( spcs_viewpoint + spcs_2bCompared + "_" + format(number_pairs_all, '05') + '\t' \
																		+ spcs_viewpoint + '\t' + bestHitOfBestHit[0] + '\t' + bestHitOfBestHit[1] + '\n')
								fout_reciprocal_bestHitAll.write( spcs_viewpoint + spcs_2bCompared + "_" + format(number_pairs_all, '05') + '\t' \
																		+ spcs_2bCompared + '\t' + bestHit[0] + '\t' + bestHit[1] + '\n')
								if 'cl' in bestHit[1] and 'cl' in bestHitOfBestHit[1]:
									number_pairs_CL = number_pairs_CL + 1
									fout_reciprocal_bestHitCL.write( spcs_viewpoint + spcs_2bCompared + "_" + format(number_pairs_all, '05') + '\t' \
																			+ spcs_viewpoint + '\t' + bestHitOfBestHit[0] + '\t' + bestHitOfBestHit[1] + '\n')
									fout_reciprocal_bestHitCL.write( spcs_viewpoint + spcs_2bCompared + "_" + format(number_pairs_all, '05') + '\t' \
																			+ spcs_2bCompared + '\t' + bestHit[0] + '\t' + bestHit[1] + '\n')
					except ValueError as err:
						print "Warning: ValueError: %s" % err								
					except KeyError as err:
						print "Warning: KeyError: %s" % err
						print "spcs_viewpoint: %s" % spcs_viewpoint
						print "spcs_2bCompared: %s" % spcs_2bCompared
						print "bestHit: %s" % bestHit
	#			print "\r   found %d and %d reciprocal bestHit and bestHit-CL pairs, respectively. " % ( number_pairs_all, number_pairs_CL)
				print "   found %d and %d reciprocal bestHit and bestHit-CL pairs, respectively. " % ( number_pairs_all, number_pairs_CL)
				fout_reciprocal_bestHitAll.close()
				fout_reciprocal_bestHitCL.close()
	
print "\ndone\n"