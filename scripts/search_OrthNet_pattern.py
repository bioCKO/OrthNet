#!/usr/bin/env python
import re,sys,os, argparse
from argparse import RawTextHelpFormatter


###################################################
### 0. script description and parsing arguments ###
###################################################
synopsis1 = "\
  find OrthNets that (1) meet a node copy number criterion and contain\n\
  a node connected to its orthologous neighbors with edges that match\n\
  a regular expression query pattern."
synopsis2 = "detailed description:\n\
 0. Pre-requisite: a combined result of a CLfinder-OrthNet run formatted by\n\
     'combine_CLfm_results.py'\n\
 1. Input files and parameters:\n\
  - './<Project>.list' includes all species IDs (spcsIDs), one per each line.\n\
  - './<Pattern>.list' is a tab-delimited list of query patterns, one query\n\
     per each line; a query start with the name of the query, followed by\n\
     (1) the node copy number criterion per each species and\n\
     (2) [optional] the query or viewpoint spcsID and the 'edge pattern'\n\
     query in regular expression;\n\
  (1) a node copy number (nodeCN) criterion is either an integer or formatted\n\
     as 'min|max' to indicate a range. e.g., '0|2' means the same or less than\n\
     2 copies, '2|~' means the same or more than two copies, '0|~' means all \n\
     values accepted, etc; assemes nodeCN criteria listed in the order of\n\
     appearance in './<Project>.list'\n\
  (2) the viewpoint spcsID and 'edge pattern' query are optional; when specified\n\
     the script looks for nodes from the viewpoint spcsID that are connected to\n\
     their neighbors with edges described in 'edge pattern'; the 'edge pattern'\n\
     list the type of edges connecting the node to its neighbors from all other\n\
     species, in the order listed in './<Project>.list,' separated by periods.\n\
  <ex> when './<Project>.list' contains spcs1, spcs2, spcs3, and spcs4,\n\
     example 1 1 2|~ 1 spcs3 cl.[tr|nd].cl\n\
	 -> this query named 'example' looks for OrthNets with (1) nodeCN in spcs3\n\
     the same or more than 2, while single copies in all other species, and\n\
     (2) contains a spcs3 node that are connected to a spcs2 node by either tr\n\
     or nd edge, while cl to nodes from spcs1 and spcs4;\n\
  - <Input> is a combeind CLfinder-OrthNet result fine generated by\n\
     'combine_CLfm_results'; <Input> must contain columns 'spcs', 'OrthNetID',\n\
     and 'OrthNet_pattern' for all gene loci;\n\
 2. Output files and options:\n\
  - '<Project>__<Pattern>.list' contains all OrthNetID, OrthNet_pattern,\n\
     and query name/annotation, tab-delimited, one OrthNetID per line.\n\
  - If an OrthNetID matches multiple query patterns, all unique query annotations\n\
     are printed, separated by commas.\n\
  - '-o'|'--Path2Output': path to other output files (dafault='.'). \n\
 by ohdongha@gmail.com ver0.1 20180419\n"
 
#version_history
#20180419 ver 0.1 modified to work with combined CLfm results and accept node copy number information separately, rather than as part of the regular expression query
#20161026 ver 0.0 formaerly 'search_OrthNet.py'
  
parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

# positional arguments
parser.add_argument('Project', type=str, help="'./<Project>.list' includes spcsIDs being compared")
parser.add_argument('Pattern', type=str, help="see below.")
parser.add_argument('Input', type=str, help="see below.")
# options indicating PATHs
parser.add_argument('-o', '--Path2Output', dest="Path2Output", type=str, default=".", help="PATH for temporary and output files") 

args = parser.parse_args()

# defining PATHs and create Output directory, if not already exisiting
path_output = args.Path2Output
if path_output[-1] != "/": path_output = path_output + "/"

try: 
	os.makedirs(path_output)
except OSError:
	if not os.path.isdir(path_output): raise


#################################################
### 1. reading spcsID and query pattern files ###
#################################################
# 1.1 reading fin_SpcsList
try:
	fin_SpcsList = open(args.Project + '.list', 'r')
except IOError:
	fin_SpcsList = open(args.Project, 'r')
print "\nreading the species/genome list file: " + fin_SpcsList.name
projectID = os.path.splitext( os.path.basename( args.Project ) )[0]

spcsID_list = []
for line in fin_SpcsList:
	spcsID_list.append(line.strip())
	print line.strip()
fin_SpcsList.close()
print "Total %d species/genome IDs detected." % (len(spcsID_list))


# 1.2 reading fin_Pattern
try:
	fin_PatternList = open(args.Pattern + '.list', 'r')
except IOError:
	fin_PatternList = open(args.Pattern, 'r')
print "\nreading the query pattern list file: " + fin_PatternList.name
queryFileName = os.path.splitext( os.path.basename( args.Pattern ) )[0]

# let's decide the output file name here:
outFileName = path_output + projectID + "__" + queryFileName + ".list" 

nodeCN_pattern_dict = dict() # key = query name, value = nodeCN_query_list, 'min|max' for each species
nodeCN_min_default = 0
nodeCN_max_default = 999
nodeCN_query_list = []
nodeCN_min = 0
nodeCN_max = 0

edgeType_query_exist = False
edgeType_viewpoint_dict = dict() # key = query name, value = viewpoint spcsID
edgeType_pattern_dict = dict() # key = query name, value = pattern (regular expression)

query_name = ""
viewpoint_spcsID = ""

for line in fin_PatternList:
	if line.strip() != "": # ignore empty lines
		tok = line.split('\t')
		
		# parsing the nodeCN pattern:
		try:
			query_name = tok[0].strip()
			nodeCN_pattern_dict[query_name] = [] # list of 'min|max' for each species
			for i in range(0, len(spcsID_list)):
				nodeCN_query_list = tok[i+1].strip().split('|')
				nodeCN_min = int( nodeCN_query_list[0] )
				if len( nodeCN_query_list ) == 1:
					nodeCN_max = nodeCN_min
				elif nodeCN_query_list[1] == '~':
					nodeCN_max = nodeCN_max_default
				else:
					nodeCN_max = int( nodeCN_query_list[1] )
				nodeCN_pattern_dict[query_name].append("%d|%d" % (nodeCN_min, nodeCN_max))
		except IndexError, ValueError:
			sys.exit( "This line does not have a valid nodeCN pattern: %s" % line )
			
		# reading the edgeType pattern, if any:
		if len(tok) >= len(spcsID_list) + 3:
			edgeType_query_exist = True
			viewpoint_spcsID = tok[ len(spcsID_list) + 1]
			if viewpoint_spcsID in spcsID_list:
				edgeType_viewpoint_dict[query_name] = viewpoint_spcsID
				edgeType_pattern_dict[query_name] = tok[ len(spcsID_list) + 2]
			else:
				print "This line does not have a valid edgeType pattern: %s" % line

print "Total %d query patterns read." % (len(nodeCN_pattern_dict))
fin_PatternList.close()


##########################################################################
### 2. reading the CLfinder-OrthNet output file and filtering OrthNets ###
##########################################################################
# 2.1. reading fin_Input and select OrthNets based on nodeCN_pattern
fin_Input = open(args.Input, 'r')

header = True
colIndex_spcs = 0
colIndex_ONid = 0
colIndex_ONpattern = 0

spcsID = ""
OrthNetID = ""
OrthNet_pattern = ""
match = ""

num_geneID = 0
ONid_selected_dict = dict() # key = query name, value = set of OrthNetIDs selected
ONid_selected_all_set = set() # set of all OrthNetIDs selected for at least one query
ONid_tested_set = set()
nodeCN_list = []
nodeCN_list_dict = dict() # key = OrthNetID, value = nodeCN_list
nodeCN = 0
nodeCN_min = 0
nodeCN_max = 0
select = False

for line in fin_Input:
	tok = line.split('\t')
	# parsing the input file header
	if header:
		try:
			colIndex_spcs = tok.index("spcs")
			colIndex_ONid = tok.index("OrthNetID")
			colIndex_ONpattern = tok.index("OrthNet_pattern")
		except ValueError:
			print "Input file does not have all required fields: spcs, OrthNetID, and OrthNet_pattern"
			sys.exit(line)
		header = False
	else:
		num_geneID += 1
		select = False
		spcsID = tok[colIndex_spcs]
		OrthNetID = tok[colIndex_ONid]
		OrthNet_pattern = tok[colIndex_ONpattern]
		if OrthNetID != '' and OrthNetID not in ONid_tested_set:
			ONid_tested_set.add(OrthNetID)
			nodeCN_list = OrthNet_pattern.split("__")[1].split('.')
			nodeCN_list_dict[OrthNetID] = nodeCN_list

			for qID in nodeCN_pattern_dict:
				if qID not in ONid_selected_dict:
					ONid_selected_dict[qID] = set() # initializing
								
				for i in range(0, len(spcsID_list)):
					nodeCN_min = int( nodeCN_pattern_dict[qID][i].split('|')[0] )
					nodeCN_max = int( nodeCN_pattern_dict[qID][i].split('|')[1] )
					nodeCN = int(nodeCN_list[i])
					if nodeCN >= nodeCN_min and nodeCN <= nodeCN_max:
						select = True
					else:
						select = False
						break
				if select:
					ONid_selected_dict[qID].add(OrthNetID)
					# this verbose reporting is for debugging: 
					#print "%d genes tested: OrthNet %s is selected for %s based on nodeCN_pattern: %s satisfying the query: %s"\
					#	% (num_geneID, OrthNetID, qID, '.'.join(nodeCN_list), '.'.join(nodeCN_pattern_dict[qID] ))

# a summarized report for nodeCN_pattern queries
print
for qID in sorted(nodeCN_pattern_dict):
	print "%d OrthNets selected for the query %s," % (len(ONid_selected_dict[qID]), qID)
	ONid_selected_all_set = ONid_selected_all_set.union(ONid_selected_dict[qID])
print "Total %d OrthNets selected for %d queries, based on nodeCN_pattern." \
		% (len(ONid_selected_all_set), len(nodeCN_pattern_dict) )
	
if edgeType_query_exist:
	print "done processing queries by nodeCN_pattern, now processing queries by edgeType_pattern:"
else:
	print "done processing queries by nodeCN_pattern, printing results to %s:" % outFileName


# 2.2. reading fin_Input again and select OrthNets based on edgeType_pattern
if edgeType_query_exist:

	fin_Input.seek(0)
	header = True		
	num_geneID = 0 # initializing
	edgeType_pattern = ""

	ONid_selected2_dict = dict() # key = query name, value = set of OrthNetIDs selected by both filters
	ONid_selected2_all_set = set() # set of all OrthNetIDs selected for at least one query, by both filters
	
	for line in fin_Input:
		tok = line.split('\t')
		# just ignore the file header
		if header:
			header = False
		else:
			num_geneID += 1
			select = False
			spcsID = tok[colIndex_spcs]
			OrthNetID = tok[colIndex_ONid]
			OrthNet_pattern = tok[colIndex_ONpattern]
			
			if OrthNetID in ONid_selected_all_set:
				for qID in edgeType_viewpoint_dict:
				
					if qID not in ONid_selected2_dict:
						ONid_selected2_dict[qID] = set() # initializing
						
					if spcsID == edgeType_viewpoint_dict[qID] and OrthNetID in ONid_selected_dict[qID]:
						edgeType_pattern = OrthNet_pattern.split("__")[0]
						match = re.search(edgeType_pattern_dict[qID].strip(), edgeType_pattern.strip())
						#print "testing whether %s matches %s: %s" % (edgeType_pattern, edgeType_pattern_dict[qID], match) # for debugging
						if match:
							ONid_selected2_dict[qID].add(OrthNetID)
							# this verbose reporting is for debugging: 
							#print "OrthNet %s selected as %s, based on edgeType: %s (%s)" \
							#	% (OrthNetID, qID, edgeType_pattern, edgeType_pattern_dict[qID])
							
	# a summarized report for nodeCN_pattern queries
	print
	for qID in sorted(edgeType_viewpoint_dict):
		print "%d OrthNets selected for the query %s," % (len(ONid_selected2_dict[qID]), qID)
		ONid_selected2_all_set = ONid_selected2_all_set.union(ONid_selected2_dict[qID])
	print "Total %d OrthNets selected for %d queries, based on nodeCN_pattern." \
			% (len(ONid_selected2_all_set), len(edgeType_viewpoint_dict) )
	print "done processing queries by edgeType_pattern, printing results to %s:" % outFileName

fin_Input.close()

	
##########################
### 3. printing output ###
##########################
# 3.1 writing the output with OrthNetID and comma-separated list of Query names
fout = open(outFileName, 'w')
fout.write("OrthNetID\tQueryNames\n") # writing the header
qID_list = []

if edgeType_query_exist:
	for ONid in sorted(ONid_selected2_all_set):
		qID_list = []
		for qID in sorted(edgeType_viewpoint_dict):
			if ONid in ONid_selected2_dict[qID]:
				qID_list.append(qID)
		fout.write("%s\t%s\n" % (ONid, ', '.join(qID_list)))
else:
	for ONid in sorted(ONid_selected_all_set):
		qID_list = []
		for qID in sorted(nocdCN_pattern_dict):
			if ONid in ONid_selected_dict[qID]:
				qID_list.append(qID)
		fout.write("%s\t%s\n" % (ONid, ','.join(qID_list)))
fout.close()

print "done"
