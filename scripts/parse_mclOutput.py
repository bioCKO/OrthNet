#!/usr/bin/env python
import sys, os, re, math, argparse
from argparse import RawTextHelpFormatter


###################################################
### 0. script description and parsing arguments ###
###################################################
synopsis1 = "\
  parse mclOutput to a tab-delimited list of geneID and clusterID, create\n\
  a summary on copy numbers of orthologous genes, and annotate clusters"
synopsis2 = "detailed description:\n\
 0. Pre-requisite: an output file from an OrthoMCL or OrthoFinder run, or\n\
     an mcl output file of similar format,\n\
 1. Input arguments, parameters, and options:\n\
  - the input file, <mclOutput>, is an output of 'mcl', a tab-delimited text\n\
     with all members (geneIDs) in a cluster listed, one cluster per line.\n\
  - <clusterID_header> is a short string.  each cluster is named as\n\
     '<clusterID_header>_XXXXX'; ignored if input is from OrthoFinder,\n\
  - '-p Path2SeqFiles': assumes the input is an 'Orthogroups.txt' file created\n\
     by OrthoFinder and Path2SeqFiles included sequence files as '<spcsID>.fa';\n\
     Do NOT use this option if the input is not an OrthoFinder output;\n\
  ** '-p _internal_' means the mclOutput in 'Orthogroups.txt' format, but spcsID\n\
     is available from the geneID (i.e. geneIDs are formatted as 'spcsID|geneID')\n\
  - '-a AnnotationFile': assumes '-S' option is on and add annotation to the\n\
     Summary report created by the '-S' option; AnnotationFile is tab-delimited\n\
     with geneID and annotation in two columns;\n\
 2. Output file and options:\n\
  - '-o output': write results to <output>.parsed.txt, and <output>.summary.txt\n\
     with '-S' or '-s' options (see below); default=${<mclOutput>%%.txt}\n\
  - '-m min_cluster_size': ignore clusters smaller than min_cluster_size;\n\
     default=2;\n\
  - '-H': add a Header line 'geneID\t<clusterID_header>';default=False,\n\
  - '-r': when geneID is formatted as 'spcsID|geneID', as in an OrthoMCL output,\n\
     remove 'spcsID|' part in output files; default=False,\n\
  - '-S': print a summary to '${<mclOutput>%%.txt}.summary.txt'; requires '-p'\n\
     parameter if the input is from orthoFinder.  Otherwise, expect the geneID\n\
     to be in OrthoMCL format, i.e., 'spcsID|geneID'; default=False,\n\
  - '-s': print a summary but don't include the gene list; default=False,\n\
  - '-x': don't print the '.parsed.txt' output; default=False.\n\
 3. Output file and options:\n\
  - make sure geneIDs are all unique, to avoid all kinds of problems,\n\
  - when '-a' is specified, add top three annotations most frequently appear\n\
     in the cluster,\n\
  - unless '-p' is specified, clusters are numbered numerically, from '00001'\n\
     to 'XXXXX' with appropriate number of '0's (i.e., rjust).\n\
by ohdongha@gmail.com 20180617 ver 1.0.5\n\n"

#version_history
#20180617 ver 1.0.5 when '-o' option not specified, print the <output>.parsed.txt to STDOUT
#20180509 ver 1.0.4 '-o' option added,
#20180329 ver 1.0.3 '-x' option added, in case only the summary file is required,
#20180320 ver 1.0.2 arguments and parameters restructured, now can annotate OrthNets generated by update_OrthNet_after_mcl.py v0.3.7+
#20180320 ver 1.0.1 with '-a' option, add the top three most represented annotations,
#20180319 ver 1.0 creates a summary report; works with OrthoFinder results,
#20171225 ver 0.2 modified to work with orthoMCL results to prepare CLfinder input,
#20160511 ver 0.1 

parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

# positional parameters
parser.add_argument('mclOutput', type=argparse.FileType('r'), help="See below")
parser.add_argument('clusterID_header', type=str, help="See below")

# options and parameters
parser.add_argument('-o', dest="output", type=str, default="_NA_", help="see below")
parser.add_argument('-p', dest="Path2SeqFiles", type=str, default="NA", help="see below")
parser.add_argument('-a', dest="AnnotationFile", type=str, default="NA", help="see below")
parser.add_argument('-m', dest="min_cluster_size", type=int, default=2, help="see below")
parser.add_argument('-H', dest="Header", action="store_true", default=False)
parser.add_argument('-r', dest="remove_speciesID", action="store_true", default=False)
parser.add_argument('-S', dest="print_summary", action="store_true", default=False)
parser.add_argument('-s', dest="print_summary_short", action="store_true", default=False)
parser.add_argument('-x', dest="no_parsed_txt", action="store_true", default=False)

args = parser.parse_args()

# if input is from OrthoFinder
toggle_OrthoFinder_input = False
toggle_spcsID_in_geneID = False
if args.Path2SeqFiles != "NA":
	toggle_OrthoFinder_input = True
	if args.Path2SeqFiles == "_internal_":
		toggle_spcsID_in_geneID = True
	else:
		Path2SeqFiles = args.Path2SeqFiles
		if Path2SeqFiles[-1] != "/": 
			Path2SeqFiles = Path2SeqFiles + "/"

# if annotation file is indicated
toggle_print_summary = args.print_summary
toggle_add_annotation = False
if args.AnnotationFile != "NA":
	toggle_print_summary = True
	toggle_add_annotation = True

# if toggle_print_summary
if args.print_summary_short:
	toggle_print_summary = True
if toggle_print_summary:
	members_in_cluster_dict = dict() # key = clusterID, value = list of geneIDs
	spcsID_list = [] # spcsID to be collected from either sequence files indicated by '-p' or from geneIDs 
	
# define output file names
if args.output != "_NA_":
	output_filename = args.output
elif args.mclOutput.name.endswith(".txt"):
	output_filename = args.mclOutput.name[:-4]
else:	
	output_filename = args.mclOutput.name

# print to STDOUT if -S, -s, or -o are not specified
toggle_print_STDOUT = False
if args.output == "_NA_" and not toggle_print_summary:
	toggle_print_STDOUT = True

###################################################
### 1.1 read input and parse the mclOutput file ###
###################################################
num_clusters_processed = 0 # this is also used for generating clusterID for non-orthoFinder input
clusterID = "" # this is for the input for orthoFinder 
clusterID_dict = dict() # key = geneID; value = clusterID
digit_for_clusterID = 0
geneID = ""

if toggle_OrthoFinder_input:
	for line in args.mclOutput:
		tok = line.split(' ')
		clusterID = tok[0].split(':')[0]
		if len(tok) > args.min_cluster_size:
			if toggle_print_summary:
				members_in_cluster_dict[clusterID] = []
			num_clusters_processed += 1
			for i in range(1, len(tok)):
				geneID = tok[i].strip()
				clusterID_dict[geneID] = clusterID
				if toggle_print_summary:
					members_in_cluster_dict[clusterID].append(geneID)
					if toggle_spcsID_in_geneID and len(geneID.split('|')) == 2 and geneID.split('|')[0] not in spcsID_list:
						spcsID_list.append(geneID.split('|')[0]) # collect spcsID here if toggle_spcsID_in_geneID

else:
	for line in args.mclOutput:
		tok = line.split()
		if len(tok) >= args.min_cluster_size:
			num_clusters_processed += 1
			if toggle_print_summary:
				members_in_cluster_dict[num_clusters_processed] = []
			for i in range(0, len(tok)):
				geneID = tok[i].strip()
				clusterID_dict[geneID] = num_clusters_processed
				if toggle_print_summary:
					members_in_cluster_dict[num_clusters_processed].append(geneID)
					if len(geneID.split('|')) == 2 and geneID.split('|')[0] not in spcsID_list:
						spcsID_list.append(geneID.split('|')[0]) # collect spcsID for orthoMCL input here
						
	digit_for_clusterID = int(math.log(num_clusters_processed,10)) + 1


#########################################################
### 1.2 read input, parse, and write .parsed.txt file ###
#########################################################
if not args.no_parsed_txt:
	if not toggle_print_STDOUT:
		fout = open(output_filename + ".parsed.txt", 'w')
	
	# write the header for ".parsed.txt" output, with '-H' option 
	if args.Header :
		if toggle_print_STDOUT:
			print ("geneID\t" + args.clusterID_header)		
		else:
			fout.write("geneID\t" + args.clusterID_header + '\n')
	
	for key, value in sorted(clusterID_dict.iteritems(), key=lambda (k, v): (v,k), reverse=False):
		# process '-r' option here
		if args.remove_speciesID:
			try:
				geneID = key.split('|')[1]
			except IndexError:
				#print "'-r' option is used, but this geneID does not have a '|' separator: %s" % key
				geneID = key
		else:
			geneID = key
		
		# write contents for ".parsed.txt" output
		if toggle_print_STDOUT:
			if toggle_OrthoFinder_input:
				print (geneID + '\t' + value)
			else:
				print (geneID + '\t' + args.clusterID_header + '_' \
							+ str(value).rjust(digit_for_clusterID, '0'))		
		else:
			if toggle_OrthoFinder_input:
				fout.write(geneID + '\t' + value + '\n')
			else:
				fout.write(geneID + '\t' + args.clusterID_header + '_' \
							+ str(value).rjust(digit_for_clusterID, '0') + '\n')
							
	if not toggle_print_STDOUT:
		print "done parsing %d clusters, for %s" % (num_clusters_processed, args.mclOutput.name)		
		fout.close()
args.mclOutput.close()


#########################################################################
### 2.1 read spcsID for all geneIDs when toggle_print_summary == True ###
#########################################################################
if toggle_print_summary and not toggle_spcsID_in_geneID:
	spcsID_dict = dict() # key = geneID, value = spcsID
	
	for filename in sorted( os.listdir(Path2SeqFiles) ):
		if filename.endswith(".fa"):
			spcsID = re.sub(".fa$","",os.path.basename(filename) )
			spcsID_list.append(spcsID)
			print "reading %s for spcsID %s" % (filename, spcsID )
			with open(os.path.join(Path2SeqFiles, filename), 'r') as f:
				for line in f:
					if line[0] == '>':
						geneID = re.sub('^>', '', line.split()[0])
						if geneID in spcsID_dict:
							print "geneID %s appeared multiple times!" % geneID
						else:
							spcsID_dict[geneID] = spcsID
			print "%d geneIDs read so far for %s species (genomes)," % ( len( spcsID_dict ), len( spcsID_list) )

#sort spcsID_list for later
if toggle_print_summary:
	spcsID_list = sorted(spcsID_list)


######################################################################
### 2.2 read and add annotation when toggle_add_annotation == True ###
######################################################################
if toggle_print_summary and toggle_add_annotation:
	Anno_geneID_dict = dict() # key = geneID, value = annotation
	Anno_clusterID_dict = dict() # key = clusterID, value = list of the three annotations
	
	AnnoFreq_geneID_dict = dict() # key = annotation, value = number of geneIDs with the annotation in the cluster
	AnnoFreq_spcsID_dict = dict() # key = annotation, value = set of spcsID that contain the annotation in the cluster
	AnnoFreq_score_dict = dict() # key = annotation, value = AnnoFreq_geneID_dict[key] + len( AnnoFreq_spcsID_dict[key] ) * 10 

	Annotation = ""
	
	# reading the annotation file
	fin_anno = open ( args.AnnotationFile, 'r' )
	print "\nreading annotation from %s" % fin_anno.name
	
	for line in fin_anno:
		tok = line.split('\t')
		geneID = tok[0].strip()
		if geneID in clusterID_dict:
			Anno_geneID_dict[ geneID ] = tok[1].strip()
			
	# deals with cases when geneID is in OrthNet node format ('spcsID|geneID') but not in the annotation file
	if	len(Anno_geneID_dict) == 0:
		print "no annotation was retrieved;" 
		print "trying again assuming geneIDs are in OrthNet/OrthoMCL format (i.e., 'spcsID|geneID')"
	
		geneID_alt_dict = dict() # key = geneID extracted from 'spcsID|geneID'; value = original geneID in OrthNet/OrthoMCL format 
		for gID in clusterID_dict:
			if '|' in gID and len(gID.split('|')) == 2:
				if gID.split('|')[1].strip() in geneID_alt_dict:
					print "Warning: parsed geneIDs %s is not unique, already in %s" % (gID.split('|')[1].strip(), geneID_alt_dict[ gID.split('|')[1].strip() ])
				geneID_alt_dict[ gID.split('|')[1].strip() ] = gID
			else:
				print "no ... geneIDs are not in OrthNet/OrthoMCL format,"
				print "try again after ensuring geneIDs are consistent between mclOutput and annotation files"
				break
		print "parsed %d geneIDs, now trying annotation again," % len(geneID_alt_dict)
		
		fin_anno.seek(0)
		for line in fin_anno:
			tok = line.split('\t')
			if tok[0].strip() in geneID_alt_dict:
#				print "trying %s as %s" % ( tok[0].strip(), geneID_alt_dict[ tok[0].strip() ])
				geneID = geneID_alt_dict[ tok[0].strip() ]
				if geneID in clusterID_dict:
					Anno_geneID_dict[ geneID ] = tok[1].strip()

	print "done reading annotation for %d genes; assigning annotation to clusters:" % len(Anno_geneID_dict)			
	fin_anno.close()
	
	# finding out the representative annotations
	for cID in members_in_cluster_dict:
		#initializing for the new cluster
		Anno_clusterID_dict[cID] = []		
		AnnoFreq_geneID_dict = dict() # key = annotation, value = number of geneIDs with the annotation in the cluster
		AnnoFreq_spcsID_dict = dict() # key = annotation, value = set of spcsID that contain the annotation in the cluster	
		AnnoFreq_score_dict = dict() # key = annotation, value = AnnoFreq_geneID_dict[key] + len( AnnoFreq_spcsID_dict[key] ) * 10 
		Annotation = ""
		
		# counting the occurrence of geneID and spcsID with the same annotation
		for gID in members_in_cluster_dict[cID]:
			if gID in Anno_geneID_dict:
				Annotation = Anno_geneID_dict[gID]
				AnnoFreq_geneID_dict[Annotation] = AnnoFreq_geneID_dict.get(Annotation, 0) + 1
				if toggle_spcsID_in_geneID:
					spcsID = gID.split('|')[0].strip()
				else:
					spcsID = spcsID_dict[gID]
				if Annotation not in AnnoFreq_spcsID_dict:
					AnnoFreq_spcsID_dict[Annotation] = {spcsID}
				else:
					AnnoFreq_spcsID_dict[Annotation].add(spcsID)
					
		# score annotations
		for An in AnnoFreq_geneID_dict:
			AnnoFreq_score_dict[An] = AnnoFreq_geneID_dict[An] + len( AnnoFreq_spcsID_dict[An] ) * 10
			
		# select the top three
		num_annotated = 0
		for An, Sc in sorted(AnnoFreq_score_dict.iteritems(), key=lambda (k, v): (v,k), reverse=True):
			if num_annotated < 3:
				Anno_clusterID_dict[cID].append( An + " || %d genes in %d spcs" % (AnnoFreq_geneID_dict[An], len(AnnoFreq_spcsID_dict[An]) ))
			else:
				break
			num_annotated += 1
		
		# if there are less than three annotations, fill with '-'
		for i in range( 0, 3 - len( Anno_clusterID_dict[cID] ) ):
			Anno_clusterID_dict[cID].append( '-' )
	
	
################################################################
### 3. print summary file when toggle_print_summary == True ###
################################################################

if toggle_print_summary:
	# sort spcsID and open output file
	fout_summary = open(output_filename + ".summary.txt", 'w')
	print "\nprinting summary to: %s" % fout_summary.name
	
	items_4header_list = ["clusterID", "#num_genes", '\t'.join(spcsID_list)]
	# print header
	if toggle_add_annotation:
		items_4header_list.append("Anno1\tAnno2\tAnno3")
	if not args.print_summary_short:
		items_4header_list.append("list_genes")
	fout_summary.write('\t'.join(items_4header_list) + '\n')
	
	# count occurrence for each spcsID and print contents
	for key in sorted(members_in_cluster_dict):
		CN_cluster_dict = dict() # key = spcsID, value = copy numbers		
		# counting copy numbers for each species
		for item in members_in_cluster_dict[key]:
			if not toggle_spcsID_in_geneID:
				try:
					spcsID = spcsID_dict[item]
					CN_cluster_dict[spcsID] = CN_cluster_dict.get(spcsID, 0) + 1
				except KeyError:
					print "Can't find the spcsID for geneID %s" % item
			else:
				spcsID = item.split('|')[0]
				if spcsID in spcsID_list:
					CN_cluster_dict[spcsID] = CN_cluster_dict.get(spcsID, 0) + 1
				else:
					print "Can't find the spcsID for geneID %s" % item
		# print summary
		CN_cluster_list = []
		items_2bPrinted_list = []
		for item in spcsID_list:
			CN_cluster_list.append( str( CN_cluster_dict.get(item, 0) ))
			
		if toggle_OrthoFinder_input:
			clusterID = key
		else:
			clusterID = args.clusterID_header + '_' + str(key).rjust(digit_for_clusterID, '0')

		items_2bPrinted_list.append(clusterID)
		items_2bPrinted_list.append( str(len( members_in_cluster_dict[key] )) )
		items_2bPrinted_list.append( '\t'.join(CN_cluster_list) )
		if toggle_add_annotation:
			items_2bPrinted_list.append( '\t'.join( Anno_clusterID_dict[key] ) )
		if args.print_summary_short == False:
			if args.remove_speciesID:
				short_geneID_list = []
				for gID in members_in_cluster_dict[key]:
					try:
						short_geneID_list.append( gID.split('|')[1].strip() )
					except KeyError:
						print "do not use '-r' option if geneIDs are not in OrthNet/OrthoMCL format"
						short_geneID_list.append( gID )
						
				items_2bPrinted_list.append( ' '.join( short_geneID_list ) )				
			else:
				items_2bPrinted_list.append( ' '.join( members_in_cluster_dict[key] ) )
		fout_summary.write('\t'.join(items_2bPrinted_list) + '\n')
	print "done printing summary.\n"
	fout_summary.close()