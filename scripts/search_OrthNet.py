#!/usr/bin/env python

import re,sys,os
import argparse
from argparse import RawTextHelpFormatter


###################################################
### 0. script description and parsing arguments ###
###################################################
synopsis1 = "\
  - find patterns using regular expression among OrthNet.\n\
  - runs on CL files resulted from 'update_OrthNet_after_mcl.py'\n\
  - print OrthNet IDs matching the pattern and annotated CL files." # 80 characters per line 
synopsis2 = "detailed description:\n\
 1. Input files and parameters:\n\
  - './<Pattern>.list' contains the annotation (name) of the pattern and\n\
     the definition in regular expression, tab-delimited, one pattern per line.\n\
  - Annotations don't need to be unique.\n\
  - <Input> is a CL file generated by 'update_OrthNet_after_mcl.py'.\n\
 2. Output files and options:\n\
  - '-o'|'--Path2Output': path to other output files (dafault='.'). \n\
  - '<Input>(-extension)__<Pattern>.list' contains all OrthNetID and pattern\n\
     annotation, tab-delimited, one OrthNetID per line.\n\
  - If an OrthNetID matches multiple patterns, all unique annotations are\n\
     printed, separated by commas.\n\
  - <Input> is updated by adding a column 'notes', which include all\n\
     annotations for members of OrthNets matching patterns.\n\
  - Updated <Input> are names '<Input>(-extention)_<pattern>.txt\n\
 by ohdongha@gmail.com ver0.3.3 20161017\n"
 
#version_history
#20161026 ver 0.0
  
parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

# positional arguments
parser.add_argument('Pattern', type=str, help="'./<Pattern>.list', see below.")
parser.add_argument('Input', type=str, help="a CL file generated by 'update_OrthNet_after_mcl.py'")
# options indicating PATHs
parser.add_argument('-o', '--Path2Output', dest="Path2Output", type=str, default=".", help="PATH for temporary and output files") 

args = parser.parse_args()


# defining PATHs and create Output directory, if not already exisiting
path_output = args.Path2Output
if path_output[-1] != "/": path_output = path_output + "/"

try: 
	os.makedirs(path_output)
except OSError:
	if not os.path.isdir(path_output): raise


#############################################################
### 1. reading in patterns and identify matching OrthNets ###
#############################################################
# 1.1 reading fin_Pattern
fin_PatternList = open(args.Pattern + '.list', 'r')

pattern_dict = dict() # key = pattern (regular expression), value = annotation

for line in fin_PatternList:
	tok = line.split('\t')
	if len(tok) > 1:
		pattern_dict[ tok[1].strip() ] = tok[0].strip()

fin_PatternList.close()

# 1.2. reading fin_Input
fin_CLfile = open(args.Input, 'r')

OrthNet_annotation_dict = dict() # key = OrthNetID, value = set of annotations
header = True
OrthNetID = ""
OrthNet_pattern = ""
match = ""

for line in fin_CLfile:
	if header: 
		header = False
	else:
		tok = line.split('\t')
		OrthNetID = tok[-6].strip()
		OrthNet_pattern = tok[-1].strip()
		if OrthNetID != "":
			if OrthNetID not in OrthNet_annotation_dict:
				OrthNet_annotation_dict[OrthNetID] = set()
			for key in pattern_dict:
				match = re.search(key, OrthNet_pattern)
				if match: 
					#print match.group()
					OrthNet_annotation_dict[OrthNetID].add(str(pattern_dict[key]))
					print "%s matches the pattern '%s', %s" % (OrthNet_pattern, key, pattern_dict[key])

for key in OrthNet_annotation_dict:
	OrthNet_annotation_dict[key] = ','.join(sorted( list( OrthNet_annotation_dict[key]) ) ).strip()


##########################
### 2. printing output ###
##########################
# 2.1 writing the list
fout_OrthNetList = open(path_output + os.path.basename(args.Input).strip('txt') + args.Pattern + '.list', 'w') 
fout_OrthNetList.write("OrthNet\tNotes\n")
for key in sorted(OrthNet_annotation_dict):
	if OrthNet_annotation_dict[key] != "":
		fout_OrthNetList.write(key + '\t' + OrthNet_annotation_dict[key] +'\n')
fout_OrthNetList.close()
	
# 2.2 updating the CL file
fout_Output = open(path_output + os.path.basename(args.Input).strip('txt') + args.Pattern + '.txt', 'w') 
fin_CLfile.seek(0)
header = True

for line in fin_CLfile:
	tok = line.split('\t')
	OrthNetID = tok[-6].strip()
	if header:
		fout_Output.write(line.strip() + "\tNote\n")
		header = False
	elif OrthNetID != "" and OrthNetID in OrthNet_annotation_dict:
		fout_Output.write(line.strip() + '\t' + OrthNet_annotation_dict[OrthNetID] + '\n')
	else:
		fout_Output.write(line.strip() + '\t\n')

fout_Output.close()		
fin_CLfile.close()		

print "done"
