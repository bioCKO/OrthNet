#!/usr/bin/env python

import sys
import argparse
from argparse import RawTextHelpFormatter

###################################################
### 0. script description and parsing arguments ###
###################################################

synopsis1 = "\
  - identifies co-linear (CL) relationship between two annotated genomes.\n\
  - accepts outputs from 'TD_finder.py' or 'CL_finder.py' (itself) as input.\n"
synopsis2 = "detailed description:\n\
 1. Input files and parameters\n\
  - <File4Qury> and <File4Sbjt> are outputs of 'TD_finder.py' or 'CL_finder.py'\n\
     for the query and the subject species, respectively.\n\
  - <BestHitPairs> is a tab-delimited file with protein-coding (pc) loci from \n\
     the query and the subject species, respectively, pairing homologous subject\n\
     loci for all query loci.\n\
  - '-u'|'--updatedBHPs' assumes 'BestHitPairs(BHPs)' files generated by\n\
     'update_BestHitPairs.py' or 'updated_OrthNet_after_mcl.py' (itself).\n\
 2. CL_type (co-linearity type) is decided as the following:\n\
  - three parameters, WINDOW_SIZE (W), NUM_CL_TRSHLD (N), and GAP_CL_TRSHLD (G)\n\
     are used, with default = {20, 4, 20}, respectively.\n\
  - 1)CL_type='lineage-specific(ls)' if no subject locus was paired with the\n\
     query in the <BestHitPairs>; 2)CL_type='co-linear(cl)' if, among upstream\n\
     or downstream W nearby loci excluding 'ls' ones, >=N loci have their\n\
     'bestHit' loci separated by the same or less than G (i.e. >=N 'co-linear'\n\
     loci in the window of size W); 3)if CL_type!='ls' nor 'cl' and the subject\n\
     chromosome too short (i.e. contains <W loci), CL_type='not determined(nd)';\n\
     4)if CL_type!='ls', 'cl', nor 'nd', CL_type='transposed(tr)'.\n\
 3. Output\n\
  - for each query locus, its 'CL_type' with its 'BestHit' locus is printed\n\
     along with all other information for the query and its 'BestHit' locus\n\
     from  <File4Qury> and <File4Sbjt>, to the tab-delimited <Outfile>.\n\
 4. Misc. details:\n\
  - <BestHitPairs> can be tabulated blast+ results with the '-max_target_seqs N'\n\
     (N>=10) option; i.e. multiple subjects for each query, with the most \n\
     similar ('BestHit') followed by next best subjects.\n\
  - for 'cl' loci, numbers of co-linear loci within the window ('cl_counts')\n\
     are reported, e.g. 'cl_u3d3' means '>=6 co-linear loci detected, with >=3\n\
     to the upstream and >=3 to the downstream'.\n\
  - the cl_count is replaced with an 'X' (e.g. 'cl_uXd3' or 'cl_u3dX') if the\n\
     'BestHit' is located in an end of subject chromosome/scaffold.\n\
  - with '-u' option, the 3rd column of <BestHitPairs> indicate which subject\n\
     locus should be the 'BestHit'; the 3rd column is to be added by either\n\
     'update_BestHitPairs.py', 'updated_OrthNet_after_mcl.py', or both.\n\n\
 by ohdongha@gmail.com 20180514 ver 0.5.5\n"

#version_history
#20180514 ver 0.5.5 # minor bug fix: made tolerant old nomenclature, either spcsIDlocusID or spcsID_locusID
#20180417 ver 0.5.4 # minor bug fix: made tolerant old nomenclature, OG (Ortholog Group)
#20171225 ver 0.5.3 # nomenclature changed: OG (Ortholog Group) -> PG (Paralog Group)
#20170316 ver 0.5.2 # 'translocated (tlc)' is now called 'transposed (tr)'
#20160911 ver 0.5.1 # count the subject locus when deciding CL
#20160815 ver 0.5 # modified to work with 'update_OrthNet_after_mcl.py' etc.
#20160613 ver 0.4 # update to receive parameters as options.
#20160324 ver 0.3.1 #if there is no change in the bestHit subject locus between adjacent query loci (e.g. due to TD in the subject species), these loci will not increase 'cl' counts.
#                  # now tries to find 'cl', even if the subject chromosome/scaffold contains less than WINDOW_SIZE loci.
#20160309 ver 0.3 #now it can accept the 3 parameters as arguments.
#20160224 ver 0.2 #CL score become 'x', instead of 0, at the end of scaffold/chromosome
#20160105 ver 0.1 #adding co-linearity information
#20160103 ver 0.0

parser = argparse.ArgumentParser(description = synopsis1, epilog = synopsis2, formatter_class = RawTextHelpFormatter)

parser.add_argument('File4Qury', type=argparse.FileType('r'), help="annotation file for the query species")
parser.add_argument('File4Sbjt', type=argparse.FileType('r'), help="annotation file for the subject species")
parser.add_argument('BestHitPairs', type=argparse.FileType('r'), help="list of most homologous subject loci for all query loci")
parser.add_argument('Outfile', type=argparse.FileType('w'), help="output file; see below for details")

# options
parser.add_argument('-u', '--updatedBHPs', action="store_true", default=False, help="use updated <BestHitPairs> files; see below")
# options to set parameters to determine co-linearity (see the synopsis):
parser.add_argument('-W', dest="window_size", type=int, default=20, help="default=20; see below") # 'window_size' should be smaller than 'locusID_gap_between_chromosome' defined in TD_finder.py (200 by default)
parser.add_argument('-N', dest="num_CL_trshld", type=int, default=4, help="default=4; see below")
parser.add_argument('-G', dest="gap_CL_trshld", type=int, default=20, help="default=20; see below")

args = parser.parse_args()

window_size = args.window_size
num_CL_trshld = args.num_CL_trshld
gap_CL_trshld = args.gap_CL_trshld
print "window_size, num_CL_trshld, gap_CL_trshld: %d %d %d" % (window_size, num_CL_trshld, gap_CL_trshld)

#########################################################################
### 1. reading data for sp1 (Query species) and sp2 (Subject species) ###
#########################################################################

print "processing %s (File4Qury) and %s (File4Sbjt):" % (args.File4Qury.name, args.File4Sbjt.name)

sp1_code = ""
sp2_code = ""

# refered using locusID (positive integer, assigned by 'TD_finder.py') as the key:
sp1_geneID_dict = dict() # dict with key = locusID (pos int), value = geneID, for the query species
sp2_geneID_dict = dict() # dict with key = locusID (pos int), value = geneID, for the subject species

# refered using geneID as the key:
sp1_locusID_dict = dict() # dict with key = geneID, value = locusID (pos int), for the query species
sp2_locusID_dict = dict() # dict with key = geneID, value = locusID (pos int), for the subject species
sp2_scfID_dict = dict() # dict with key = geneID, value = scfID (pos int), for the subject species
sp2_PGid_dict = dict() # dict with key = geneID, value = PGid, for the subject species
sp2_TDid_dict = dict() # dict with key = geneID, value = TDid, for the subject species

sp1_bestHit_in_sp2_dict = dict() # dict with key = query geneID, value = BestHit subject geneID
if args.updatedBHPs == True: sp1_bestHitRank_in_sp2_dict = dict() # dict with key = query geneID, value = the 'Rank' of the BestHit
sp1_CLtype_dict = dict() # dict with key = query geneID, value = 'CL_type' code

# to be used for calling co-linear loci, refered using scf/chr IDs:
sp1_numLoci_in_scf_dict = dict() # dict with key = geneID, value = num_loci in the scf/chr, for the query
sp2_numLoci_in_scf_dict = dict() # dict with key = geneID, value = num_loci in the scf/chr, for the subject

# others:
geneID = ""
scfID = ""
PGid =""
locusID = 0
TDid = ""
bestHit = ""
number_genes_sp1 = 0 
number_genes_sp2 = 0 

# reading File4Qury file
header = 1
for line in args.File4Qury:
	if header == 1:
		sp1_code = line.split('\t')[12].replace('locusID','').strip() # getting the spcsID from the header # v0.5.5 fix
		if sp1_code.endswith('_'): # v0.5.5 fix
			sp1_code = sp1_code[:-1]
		header = 0
	else:	
		try:
			tok = line.split('\t')
			geneID = tok[0].strip()
			scfID = tok[1].strip()
			locusID = int(tok[12].strip())
			
			sp1_geneID_dict[locusID] = geneID
			sp1_locusID_dict[geneID] = locusID
			
			if scfID in sp1_numLoci_in_scf_dict:
				sp1_numLoci_in_scf_dict[scfID] = sp1_numLoci_in_scf_dict[scfID] + 1
			else:
				sp1_numLoci_in_scf_dict[scfID] = 1			
			number_genes_sp1 = number_genes_sp1 + 1
			
		except (ValueError, IndexError) :
			print "There is a non-valid line... -3-"

# reading File4Sbjt file
header = 1
for line in args.File4Sbjt:
	if header == 1:
		sp2_code = line.split('\t')[12].replace('locusID','').strip() # getting the spcsID from the header # v0.5.5 fix
		if sp2_code.endswith('_'): # v0.5.5 fix
			sp2_code = sp2_code[:-1]
		header = 0
	else:	
		try:
			tok = line.split('\t')
			geneID = tok[0].strip()
			scfID = tok[1].strip()
			PGid = tok[11].strip()
			locusID = int(tok[12].strip())
			TDid = tok[13].strip()

			sp2_geneID_dict[locusID] = geneID
			sp2_scfID_dict[geneID] = scfID
			sp2_PGid_dict[geneID] = PGid
			sp2_locusID_dict[geneID] = locusID
			sp2_TDid_dict[geneID] = TDid

			if scfID in sp2_numLoci_in_scf_dict:
				sp2_numLoci_in_scf_dict[scfID] = sp2_numLoci_in_scf_dict[scfID] + 1
			else:
				sp2_numLoci_in_scf_dict[scfID] = 1			
			number_genes_sp2 = number_genes_sp2 + 1			

		except (ValueError, IndexError) :
			print "There is either a non-valid line... :P"

# reading BestHitPairs file			
for line in args.BestHitPairs:
	try:
		tok = line.split('\t')
		geneID = tok[0].strip()
		bestHit = tok[1].strip()
		if args.updatedBHPs == True:
			if len(tok) == 3 and geneID in sp1_locusID_dict and geneID not in sp1_bestHit_in_sp2_dict: # select BestHits marked by 'update...' scripts
				sp1_bestHit_in_sp2_dict[geneID] = bestHit
				sp1_bestHitRank_in_sp2_dict[geneID] = tok[2].strip()
		elif geneID in sp1_locusID_dict and geneID not in sp1_bestHit_in_sp2_dict: # takes only the first occurance as 'bestHit'
			sp1_bestHit_in_sp2_dict[geneID] = bestHit
	except (ValueError, IndexError) :
		print "There is a non-valid line... -_-;;"

args.File4Sbjt.close()
args.BestHitPairs.close()


#####################################################
### 2. identifying co-linearity types ('CL_type') ###
#####################################################

geneID = ""
scfID = ""
locusID = 0

locusID_being_searched = 0
geneID_being_searched = ""
bestHit_locus = 0
bestHit_locus_prev =0
searched_loci_counter = 0
accepted_loci_counter = 0
colinear_loci_counter = 0
colinear_loci_up = 0 
colinear_loci_down = 0 

# CL_decision: 0 == not decided, 1 == decided  
CL_decision = 0

# finding co-linearity
header = 1
args.File4Qury.seek(0) # reading from the beginning of the File4Qury again
for line in args.File4Qury:
	if header == 1:
		#sp1_code = line.split('\t')[12].replace('_locusID','').strip()
		header = 0
	else:	
		try:
			tok = line.split('\t')
			geneID = tok[0].strip()
			scfID = tok[1].strip()
			locusID = int(tok[12].strip())
			CL_decision = 0
			colinear_loci_up = 0 
			colinear_loci_down = 0 
#			sys.stdout.write("\r   searching colinearity between %s and %s, for %s locus %d " % (sp1_code, sp2_code, sp1_code, int(locusID)) )
#			sys.stdout.flush()

			# first, deal with loci with no "bestHit", "bestHit" that is not pc, or on a scf/chr that is too small
			if geneID not in sp1_bestHit_in_sp2_dict:
				sp1_CLtype_dict[geneID] = 'ls'
				CL_decision = 1
			elif sp1_bestHit_in_sp2_dict[geneID] not in sp2_locusID_dict:
				sp1_CLtype_dict[geneID] = 'nd_bestHitNotPC' # 'bestHit' is not found in the <File4Sbjt>, somthing wrong with the <BestHitPairs> file
				CL_decision = 1

			# second, search upstream and count co-linear loci
			if CL_decision == 0:
				searched_loci_counter = 0
				accepted_loci_counter = 0
				colinear_loci_counter = 0
				bestHit_locus = sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID]]
				bestHit_locus_prev = bestHit_locus
				while accepted_loci_counter <= window_size and CL_decision == 0 :
					searched_loci_counter = searched_loci_counter - 1
					locusID_being_searched = locusID + searched_loci_counter					
					if locusID_being_searched in sp1_geneID_dict:
						geneID_being_searched = sp1_geneID_dict[locusID_being_searched]
						if geneID_being_searched in sp1_bestHit_in_sp2_dict:
#							if sp1_bestHit_in_sp2_dict[geneID_being_searched] in sp2_locusID_dict : ## removed in ver 0.3.1
							if sp1_bestHit_in_sp2_dict[geneID_being_searched] in sp2_locusID_dict \
									and bestHit_locus_prev != sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]:	## added in ver 0.3.1 
								accepted_loci_counter = accepted_loci_counter + 1
								if abs(bestHit_locus_prev - sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]) <= gap_CL_trshld: 
									bestHit_locus_prev = bestHit_locus
									bestHit_locus = sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]
									if bestHit_locus != bestHit_locus_prev:
										colinear_loci_counter = colinear_loci_counter + 1
					else:
						accepted_loci_counter = window_size + 1 # when reached at an end of scf/chr, stop searching
					if colinear_loci_counter >= num_CL_trshld:
						accepted_loci_counter = window_size + 1 # if co-linearity is found, stop searching			
				colinear_loci_up = colinear_loci_counter
				
			# third, search downstream and count co-linear loci
			if CL_decision == 0:
				searched_loci_counter = 0
				accepted_loci_counter = 0
				colinear_loci_counter = 0
				bestHit_locus = sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID]]
				bestHit_locus_prev = bestHit_locus
				while accepted_loci_counter <= window_size and CL_decision == 0:
					searched_loci_counter = searched_loci_counter + 1 # searching downstream
					locusID_being_searched = locusID + searched_loci_counter					
					if locusID_being_searched in sp1_geneID_dict:
						geneID_being_searched = sp1_geneID_dict[locusID_being_searched]
						if geneID_being_searched in sp1_bestHit_in_sp2_dict:
#							if sp1_bestHit_in_sp2_dict[geneID_being_searched] in sp2_locusID_dict : ## removed in ver 0.3.1
							if sp1_bestHit_in_sp2_dict[geneID_being_searched] in sp2_locusID_dict \
									and bestHit_locus_prev != sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]:	## added in ver 0.3.1 
								accepted_loci_counter = accepted_loci_counter + 1
								if abs(bestHit_locus_prev - sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]) <= gap_CL_trshld: 
									bestHit_locus_prev = bestHit_locus
									bestHit_locus = sp2_locusID_dict[sp1_bestHit_in_sp2_dict[geneID_being_searched]]
									if bestHit_locus != bestHit_locus_prev:
										colinear_loci_counter = colinear_loci_counter + 1
					else:
						accepted_loci_counter = window_size + 1 # when reached at an end of scf/chr, stop searching
					if colinear_loci_counter >= num_CL_trshld:
						accepted_loci_counter = window_size + 1 # if co-linearity is found, stop searching
				colinear_loci_down = colinear_loci_counter

			# fourth, decide and generate CL information
			if CL_decision == 0 and (colinear_loci_up + colinear_loci_down) >= (num_CL_trshld - 1 ): # inclduing the subject locus, hence (num_CL_trshld -1) 
				if colinear_loci_up == 0 and ( ((locusID - window_size) not in sp1_geneID_dict) or ((bestHit_locus - window_size) not in sp2_geneID_dict) or ((bestHit_locus + window_size) not in sp2_geneID_dict) ):
					sp1_CLtype_dict[geneID] = 'cl_uXd' +str(colinear_loci_down)
				elif colinear_loci_down == 0 and ( ((locusID + window_size) not in sp1_geneID_dict) or ((bestHit_locus - window_size) not in sp2_geneID_dict) or ((bestHit_locus + window_size) not in sp2_geneID_dict) ):
					sp1_CLtype_dict[geneID] = 'cl_u' + str(colinear_loci_up) + 'dX'
				else:
					sp1_CLtype_dict[geneID] = 'cl_u' + str(colinear_loci_up) + 'd' +str(colinear_loci_down)
				CL_decision = 1
				
			# fifth, declare eiter "nd" or "tr", if none of above
			if CL_decision == 0:
				# let's think about this issue later (whether to consider subject scf/chr lengths to determine 'nd' as well)
				#if sp1_numLoci_in_scf_dict[scfID] < window_size or sp2_numLoci_in_scf_dict[ sp2_scfID_dict[sp1_bestHit_in_sp2_dict[geneID]] ] < window_size : 
				if sp1_numLoci_in_scf_dict[scfID] < window_size:
					sp1_CLtype_dict[geneID] = 'nd' # modified / added in ver 0.31
					CL_decision = 1
				else:
					sp1_CLtype_dict[geneID] = 'tr'
					CL_decision = 1
			
			# finally, add 'BestHit_rank' information, if '-u' was specified.
			if args.updatedBHPs == True and geneID in sp1_bestHitRank_in_sp2_dict:
				if sp1_bestHitRank_in_sp2_dict[geneID] != 'BH1' and sp1_bestHitRank_in_sp2_dict[geneID] != 'BHx':
					sp1_CLtype_dict[geneID] = sp1_CLtype_dict[geneID] + '_' + sp1_bestHitRank_in_sp2_dict[geneID].strip()
					#print "geneID = %s, CLtype = %s, BestHit_rank = %s" % (geneID, sp1_CLtype_dict[geneID], sp1_bestHitRank_in_sp2_dict[geneID])

		except (ValueError, IndexError) :
			print "There is a non-valid line... -3-"
			

#########################
### 3. writing output ###
#########################

geneID = ""
bestHit = ""

print "writing to %s :" % args.Outfile.name

header = 1
line_written = 0
args.File4Qury.seek(0) # reading from the beginning of the File4Qury again

for line in args.File4Qury:
	line_written = 0
	if header == 1:
		args.Outfile.write(line.strip() + '\t' \
					+ sp1_code + '-' + sp2_code + "_CL" + str(window_size) + "." + str(num_CL_trshld) + "." + str(gap_CL_trshld) + '\t' \
					+ sp2_code + "_geneID" + '\t' + sp2_code + "_PG" + '\t' + sp2_code + "_locusID" + '\t' + sp2_code + "_TDid" +'\n')
		header = 0
		line_written = 1
	else:
		try:
			tok = line.split('\t')
			geneID = tok[0].strip()
			if geneID in sp1_bestHit_in_sp2_dict:
				bestHit = sp1_bestHit_in_sp2_dict[geneID]
				if bestHit in sp2_locusID_dict:
					args.Outfile.write(line.strip() + '\t' + sp1_CLtype_dict[geneID] + '\t' + bestHit + '\t' + sp2_PGid_dict[bestHit] + '\t' + str(sp2_locusID_dict[bestHit]) + '\t' + sp2_TDid_dict[bestHit] +'\n')
					line_written = 1
				else:
					args.Outfile.write(line.strip() + '\t' + sp1_CLtype_dict[geneID] + '\t' + bestHit + '\tna\tna\tna\n')
					line_written = 1
					print "Did you use exactly the same gene IDs for TD_finder.py and blast?... []_[] : %s" % bestHit					
			else:
				args.Outfile.write(line.strip() + '\t' + sp1_CLtype_dict[geneID] + '\tna\tna\tna\tna\n')
				line_written = 1	
		except (ValueError, IndexError) :
			print "There is a line with invalid column value(s)... -_-;;"
		except KeyError :
			print "KeyError, for unknown reason : %s" % bestHit
			if line_written != 1:
				args.Outfile.write(line.strip() + '\tna\tna\tna\tna\n')
args.File4Qury.close()
args.Outfile.close()

#print "done.\n"